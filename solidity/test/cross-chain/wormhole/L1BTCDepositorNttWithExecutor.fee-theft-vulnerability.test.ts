import { ethers, helpers } from "hardhat"
import { expect } from "chai"
import { BigNumber } from "ethers"
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers"
import type {
  L1BTCDepositorNttWithExecutor,
  MockTBTCBridge,
  MockTBTCVault,
  TestERC20,
} from "../../../typechain"
import { REAL_SIGNED_QUOTE } from "./realSignedQuote"

const { createSnapshot, restoreSnapshot } = helpers.snapshot

// Wormhole Chain IDs for testing
const WORMHOLE_CHAIN_SEI = 32

describe("L1BTCDepositorNttWithExecutor - Fee Theft Vulnerability Test", () => {
  let depositor: L1BTCDepositorNttWithExecutor
  let bridge: MockTBTCBridge
  let tbtcVault: MockTBTCVault
  let tbtcToken: TestERC20
  let owner: SignerWithAddress
  let maliciousActor: SignerWithAddress
  let legitimateUser: SignerWithAddress
  let protocolFeeRecipient: SignerWithAddress

  before(async () => {
    // eslint-disable-next-line @typescript-eslint/no-extra-semi
    ;[owner, maliciousActor, legitimateUser, protocolFeeRecipient] =
      await ethers.getSigners()

    // Deploy mock contracts
    const TestERC20Factory = await ethers.getContractFactory("TestERC20")
    tbtcToken = await TestERC20Factory.deploy()

    const MockBridgeFactory = await ethers.getContractFactory("MockTBTCBridge")
    bridge = await MockBridgeFactory.deploy()

    const MockTBTCVaultFactory = await ethers.getContractFactory(
      "contracts/test/MockTBTCVault.sol:MockTBTCVault"
    )
    tbtcVault = (await MockTBTCVaultFactory.deploy()) as MockTBTCVault
    await tbtcVault.setTbtcToken(tbtcToken.address)

    // Mock NTT managers
    const nttManagerWithExecutor = {
      address: ethers.Wallet.createRandom().address,
    }
    const underlyingNttManager = {
      address: ethers.Wallet.createRandom().address,
    }

    // Deploy main contract with proxy
    const L1BTCDepositorFactory = await ethers.getContractFactory(
      "L1BTCDepositorNttWithExecutor"
    )
    const depositorImpl = await L1BTCDepositorFactory.deploy()
    await depositorImpl.deployed()

    // Deploy proxy
    const ProxyFactory = await ethers.getContractFactory("ERC1967Proxy")
    const initData = depositorImpl.interface.encodeFunctionData("initialize", [
      bridge.address,
      tbtcVault.address,
      nttManagerWithExecutor.address,
      underlyingNttManager.address,
    ])
    const proxy = await ProxyFactory.deploy(depositorImpl.address, initData)

    depositor = L1BTCDepositorFactory.attach(
      proxy.address
    ) as L1BTCDepositorNttWithExecutor

    // Set up supported chains and default platform fee
    await depositor.setSupportedChain(WORMHOLE_CHAIN_SEI, true)
    await depositor.setDefaultSupportedChain(WORMHOLE_CHAIN_SEI)

    // Set default platform fee to 1% with protocol-controlled recipient
    await depositor.setDefaultParameters(
      500000, // gas limit
      0, // executor fee
      ethers.constants.AddressZero, // executor fee recipient
      100, // 0.1% platform fee (100/100000)
      protocolFeeRecipient.address // platform fee recipient
    )
  })

  beforeEach(async () => {
    await createSnapshot()
  })

  afterEach(async () => {
    await restoreSnapshot()
  })

  describe("Fee Theft: Deposit Theft Through Malicious Executor Fee Parameters", () => {
    it("FIX APPLIED: should reject malicious actor trying to set their own fee payee address", async () => {
      // This test demonstrates the FIX is now applied and working

      const maliciousPayeeAddress = maliciousActor.address

      const executorArgs = {
        value: ethers.utils.parseEther("0.01"),
        refundAddress: maliciousActor.address,
        signedQuote: REAL_SIGNED_QUOTE.signedQuote,
        instructions: REAL_SIGNED_QUOTE.relayInstructions,
      }

      // Malicious actor tries to set fee parameters with THEIR OWN payee address
      const maliciousFeeArgs = {
        dbps: 10000, // Maximum fee: 10% (10000/100000)
        payee: maliciousPayeeAddress, // MALICIOUS: Using their own address instead of protocol address
      }

      // AFTER FIX: This transaction is now properly blocked
      await expect(
        depositor
          .connect(maliciousActor)
          .setExecutorParameters(executorArgs, maliciousFeeArgs)
      ).to.be.revertedWith(
        "Fee payee must match default platform fee recipient"
      )

      console.log(
        "FIX CONFIRMED: Malicious actor is blocked from setting their own fee payee!"
      )
      console.log(`   Attempted malicious payee: ${maliciousPayeeAddress}`)
      console.log(`   Required protocol payee: ${protocolFeeRecipient.address}`)
      console.log(`   Transaction correctly reverted`)
    })

    it("FIX APPLIED: should reject fee payee that doesn't match protocol recipient (alt test)", async () => {
      // Alternative test confirming the fix with different actor

      const differentMaliciousAddress = legitimateUser.address

      const executorArgs = {
        value: ethers.utils.parseEther("0.01"),
        refundAddress: differentMaliciousAddress,
        signedQuote: `0x${"1".repeat(128)}`,
        instructions: REAL_SIGNED_QUOTE.relayInstructions,
      }

      // Different actor tries to set fee parameters with wrong payee address
      const maliciousFeeArgs = {
        dbps: 100, // 0.1% fee (100/100000)
        payee: differentMaliciousAddress, // Wrong address
      }

      // AFTER FIX: This correctly reverts
      await expect(
        depositor
          .connect(legitimateUser)
          .setExecutorParameters(executorArgs, maliciousFeeArgs)
      ).to.be.revertedWith(
        "Fee payee must match default platform fee recipient"
      )
    })

    it("AFTER FIX: should allow legitimate parameters with protocol fee recipient", async () => {
      // This test shows legitimate use still works after fix

      const executorArgs = {
        value: ethers.utils.parseEther("0.01"),
        refundAddress: legitimateUser.address,
        signedQuote: `0x${"1".repeat(128)}`,
        instructions: REAL_SIGNED_QUOTE.relayInstructions,
      }

      // Legitimate parameters using the protocol's fee recipient
      const legitimateFeeArgs = {
        dbps: 100, // 0.1% fee (100/100000)
        payee: protocolFeeRecipient.address, // Correct: Using protocol address
      }

      // This should succeed
      await expect(
        depositor
          .connect(legitimateUser)
          .setExecutorParameters(executorArgs, legitimateFeeArgs)
      ).to.not.be.reverted

      console.log("Legitimate parameters accepted with protocol fee recipient")
    })

    it("ATTACK BLOCKED: demonstrates attack is now prevented", async () => {
      // Step 1: Legitimate user initializes a deposit
      console.log("\n=== ATTACK PREVENTION DEMONSTRATION ===")
      console.log("Step 1: Legitimate user would initialize deposit")

      // Simulate deposit initialization (simplified)
      const depositAmount = ethers.utils.parseEther("1") // 1 tBTC

      // Step 2: Malicious actor TRIES to set parameters with their payee
      console.log(
        "Step 2: Malicious actor ATTEMPTS to set executor parameters with their own payee"
      )

      const executorArgs = {
        value: ethers.utils.parseEther("0.01"),
        refundAddress: maliciousActor.address,
        signedQuote: `0x${"1".repeat(128)}`,
        instructions: REAL_SIGNED_QUOTE.relayInstructions,
      }

      const maliciousFeeArgs = {
        dbps: 10000, // 10% fee
        payee: maliciousActor.address, // Attacker's address
      }

      // Step 3: Attack is blocked by the fix
      console.log("Step 3: Attack is BLOCKED by validation")

      await expect(
        depositor
          .connect(maliciousActor)
          .setExecutorParameters(executorArgs, maliciousFeeArgs)
      ).to.be.revertedWith(
        "Fee payee must match default platform fee recipient"
      )

      console.log(`   Transaction reverted`)
      console.log(`   Attacker cannot set payee to: ${maliciousActor.address}`)
      console.log(`   Attack prevented - no deposits can be stolen!`)
      console.log(
        `   User would receive full amount: ${ethers.utils.formatEther(
          depositAmount
        )} tBTC (minus legitimate platform fee)`
      )
      console.log(
        `   Protocol receives proper fees at: ${protocolFeeRecipient.address}`
      )

      console.log("\nFIX SUCCESSFUL: Validation prevents fee theft attack!\n")
    })

    it("should allow zero fee with zero address when platform fee is zero", async () => {
      // Reset platform fee to zero
      await depositor.setDefaultParameters(
        500000,
        0,
        ethers.constants.AddressZero,
        0, // Zero platform fee
        ethers.constants.AddressZero // Zero address ok when fee is zero
      )

      const executorArgs = {
        value: ethers.utils.parseEther("0.01"),
        refundAddress: legitimateUser.address,
        signedQuote: `0x${"1".repeat(128)}`,
        instructions: REAL_SIGNED_QUOTE.relayInstructions,
      }

      const zeroFeeArgs = {
        dbps: 0,
        payee: ethers.constants.AddressZero,
      }

      // Should succeed when platform fee is zero
      await expect(
        depositor
          .connect(legitimateUser)
          .setExecutorParameters(executorArgs, zeroFeeArgs)
      ).to.not.be.reverted
    })
  })
})
